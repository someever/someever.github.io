---
layout: post
title: "Redis"
tag: "技术原理"
---
记录关于Redis相关的一些关键点，可用于系统的复习框架或者面试前的突击

# 特点
单线程，多数据结构，高性能：读11w/s，写8.1w/s，可以持久化

# 数据类型：
- string：int，sds，embstr（长度小于39字节,连续内存）
- hash：ziplist（长度小于64字节且数量小于512，节省内存），hashtable
- list：ziplist（长度小于64字节且数量小于512），linkedlist
- set：intset（数量小于512），hashtable
- zset：ziplist（长度小于64字节且数量小于128），skiplist

# 持久化
- RDB和AOF，
    - RDB是快照，异步，性能好，文件小，一段时间备份会丢失数据，恢复快
    - AOF可以实时记录，即使是1s一次，也只丢1s数据，文件大，恢复慢
    - 线上实际使用根据情况，可以结合使用，也可以从库做持久化
- 过期删除策略：
    - 定时删除：设置过期时间的同时起个timer，到期自动删除，对内存友好能及时删，耗cpu
    - 惰性删除：查的时候删，对cpu友好，耗内存
    - 定期删除：定期扫描过期的键，删除，可以定期释放内存，具体频率不太好把控，还有可能返回旧值
    - 实际线上使用可以结合惰性和定期（默认10次/s）
- 淘汰策略
    - volatile-lru   有过期时间的使用率低的 (LRU:最近使用 Least Recently Used ) 。
    - allkeys-lru   利用LRU算法移除任何key （和上一个相比，删除的key包括设置过期时间和不设置过期时间的）。通常使用该方式
    - volatile-random 有过期时间的随机
    - allkeys-random  无差别随机。
    - volatile-ttl  有过期时间的快过期的
    - noeviction 不移除任何key，只是返回一个写错误 ，默认选项，一般不会选用。

# 部署方式
- 主从：略
- sentinel：高可用，哨兵监控，主节点故障，重新选主
- cluster：数据分片，分布式存储，16384个槽位，分别对应到节点上

# 缓存
- 常见问题
    - 缓存穿透：大量访问缓存中没有的key，造成请求打到数据库（业务校验，将不存在的key也缓存空值，布隆过滤器）
    - 缓存击穿：热点key过期，请求都打到数据库（热key永不过期，定期更新，更新时加锁）
    - 缓存雪崩：同一时间大量key失效或者redis宕机（过期时间random，提前预热，保证高可用）
- 缓存更新
    - 更新策略（先删后更，先更后删，先更数据库再更缓存，Read/Write Through，写回先缓存再落库），一致性问题

